<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数柯里化</title>
      <link href="/2020/09/07/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2020/09/07/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>函数式编程有一个规定：就是一个函数只能有一个参数，实现函数不耦合， 处理单一数据。why?</p><a id="more"></a><p>在刷js基础题时，遇到过这样一道题，实现一个方法add，使add(1,2)=3,add(1)(2)=3。WTF？一个函数怎么接受两个参数？带着问题去查询，就是一个函数柯里化的实现。</p><h2 id="首先了解一下柯里化是什么"><a href="#首先了解一下柯里化是什么" class="headerlink" title="首先了解一下柯里化是什么"></a>首先了解一下柯里化是什么</h2><blockquote><p>维基百科上说道：柯里化，英语：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>看着这词条解释有一点抽象，我们就拿上题的实现来做个示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通的add</span><br><span class="line">function add (a: number, b: number): number &#123;</span><br><span class="line">return a+b</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实现多个参数的add</span><br><span class="line">function add () :any &#123;</span><br><span class="line">    &#x2F;&#x2F;利用闭包，不断的保存参数(arguments)</span><br><span class="line">let args: number[] &#x3D; Array.prototype.slice.call(arguments)</span><br><span class="line">let _add &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">if(arguments.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;当新的参数为空，调用加法</span><br><span class="line">return args.reduce((a,b)&#x3D;&gt;a+b)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;否则，继续将新参数添加进args，并返回个新函数接受新参数</span><br><span class="line">Array.prototype.push..apply(args,arguments)</span><br><span class="line">retuen _add</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return _add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js函数 柯里化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es2020新特性</title>
      <link href="/2020/09/01/es2020%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/"/>
      <url>/2020/09/01/es2020%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>ES2020</strong>是ECMA, <a href="https://link.zhihu.com/?target=https://github.com/tc39">TC39</a>（技术委员会）发布的最新的JavaScript版本。</p><p><strong>ECMA</strong>全名<strong>European Computer Manufacturers Association</strong>（欧洲计算机制造商协会），是一个和ISO、W3C一样国际标准组织。</p><a id="more"></a><h2 id="合并空运算符"><a href="#合并空运算符" class="headerlink" title="合并空运算符"></a>合并空运算符</h2><p>在开发中，为了确保某个字段存在，我们往往会用c = a || b的方式，当a不存在时，确保c有个初始值b,但这种在a=0或者a=’’时会出错，让我们不得不对这些特殊值另加判断。<br>ES2020出了新的判断符号？？确保a只在为null或undefined是，在会执行右边</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(age || <span class="number">18</span>) <span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(age ?? <span class="number">18</span>) <span class="comment">//0</span></span><br><span class="line">??可精确比较 为<span class="literal">null</span>或underfined才为后者</span><br></pre></td></tr></table></figure><h2 id="链接操作符"><a href="#链接操作符" class="headerlink" title="链接操作符"></a>链接操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (res1 &amp;&amp; res1.data &amp;&amp; res1.data.data &amp;&amp; res1.data.data.hasProcessing) &#123;...&#125;</span><br><span class="line">if(res1?.data?.data?.hasProcessing)</span><br></pre></td></tr></table></figure><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">promise.all可以一起调用多个任务，一个任务出错，就全错了，新的可以确保其他的都能正常运行</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">200</span>, <span class="string">&#x27;ok&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;bad&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会触发</span></span><br><span class="line">   &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// bad</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 会触发，获取不到我们想要的内容</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises)</span><br><span class="line">  .then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// &#123;status: &quot;fulfilled&quot;, value: &quot;ok&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#123;status: &quot;rejected&quot;, reason: &quot;bad&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="大整数bigInt"><a href="#大整数bigInt" class="headerlink" title="大整数bigInt"></a>大整数bigInt</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js最大整数为<span class="number">2</span>^<span class="number">53</span><span class="number">-1</span>,<span class="attr">numbe</span>:MAX_SAFE_INTERGEF,超过这个值后，运算会造成精度丢失</span><br><span class="line">数字后面加n  如<span class="number">2n</span> == <span class="number">2</span>/<span class="literal">true</span> <span class="number">2n</span>===<span class="number">2</span>/<span class="literal">false</span></span><br><span class="line">大整数只能和大整数进行运算 </span><br><span class="line">number(<span class="number">2n</span>) bigInt(<span class="number">2</span>)转换，精度会丢失</span><br><span class="line">+ - 不会隐式转换 会报错</span><br><span class="line">其他运算基本和number相同</span><br></pre></td></tr></table></figure><h2 id="动态引入（next已经支持）"><a href="#动态引入（next已经支持）" class="headerlink" title="动态引入（next已经支持）"></a>动态引入（next已经支持）</h2><p>利用async await 实现某些组件按需加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const addForMath &#x3D; async (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  if (a &amp;&amp; b) &#123;</span><br><span class="line">    const math &#x3D; await import(&#39;.&#x2F;math.js&#39;);</span><br><span class="line">    console.log(math.add(5, 10));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 ES2020 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
