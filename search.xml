<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数柯里化</title>
      <link href="/2020/09/07/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2020/09/07/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>函数式编程有一个规定：就是一个函数只能有一个参数，实现函数不耦合， 处理单一数据。他和函数柯里化有关系吗？</p><a id="more"></a><p>在刷js基础题时，遇到过这样一道题，实现一个方法add，使add(1,2)=3,add(1)(2)=3。WTF？一个函数怎么接受两个参数？带着问题去查询，就是一个函数柯里化的实现。</p><h2 id="首先了解一下柯里化是什么"><a href="#首先了解一下柯里化是什么" class="headerlink" title="首先了解一下柯里化是什么"></a>首先了解一下柯里化是什么</h2><blockquote><p>维基百科上说道：柯里化，英语：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>看着这词条解释有一点抽象，我们就拿上题的实现来做个示例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的add</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现多个参数的add</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">...a: <span class="built_in">number</span>[]</span>) :<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="comment">//利用闭包，不断的保存参数(arguments)</span></span><br><span class="line"><span class="keyword">let</span> args: <span class="built_in">number</span>[] = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"><span class="keyword">let</span> _add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//否则，继续将新参数添加进args，并返回个新函数接受新参数</span></span><br><span class="line">args.push(...arguments);</span><br><span class="line"><span class="keyword">return</span> _add</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _add.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sum:<span class="built_in">number</span> = args.reduce(<span class="function">(<span class="params">a: <span class="built_in">number</span>,b: <span class="built_in">number</span></span>)=&gt;</span>a+b)</span><br><span class="line">        <span class="keyword">return</span> sum.toString()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> _add</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>))  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="柯里化有什么好处呢"><a href="#柯里化有什么好处呢" class="headerlink" title="柯里化有什么好处呢"></a>柯里化有什么好处呢</h2><p>函数柯里化主要有三个作用 1.参数复用 2.提前返回 3.延迟执行</p><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正则检测类型</span><br><span class="line">&#x2F;&#x2F;以前写法</span><br><span class="line">function check(reg: RegExp, str: string): boolean &#123;</span><br><span class="line">return reg.test(str)</span><br><span class="line">&#125;</span><br><span class="line">check(&#x2F;\d+&#x2F;g,&#39;1213&#39;) &#x2F;&#x2F;true</span><br><span class="line">check(&#x2F;\d+&#x2F;g,&#39;str&#39;) &#x2F;&#x2F;flase</span><br><span class="line">&#x2F;&#x2F;柯里化后</span><br><span class="line">function curCheck(reg: RegExp): any &#123;</span><br><span class="line">return function(str: string): boolean &#123;</span><br><span class="line">return reg.test(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">const hasNumber &#x3D; curCheck(&#x2F;\d+&#x2F;g)</span><br><span class="line">const hasString &#x3D; curCheck(&#x2F;[a-z][A-Z]&#x2F;g)</span><br><span class="line">hasNumber(&#39;123&#39;) &#x2F;&#x2F;true</span><br><span class="line">hasString(&#39;123&#39;) &#x2F;&#x2F;flase</span><br></pre></td></tr></table></figure><h3 id="提前返回"><a href="#提前返回" class="headerlink" title="提前返回"></a>提前返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正常情况</span><br><span class="line">const addEvent &#x3D; function(element: HTMLElement,event: Event,handler: any): void&#123;</span><br><span class="line">if(document.addEventListener)&#123;</span><br><span class="line">if(element &amp;&amp; event &amp;&amp; handler)&#123;</span><br><span class="line">element.addEvementListener(event,handler)</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if(element &amp;&amp; event &amp;&amp; handler)&#123;</span><br><span class="line">element.attachEvent(&#39;on&#39;+event,handler)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;柯里化</span><br><span class="line">const on &#x3D; (function() &#123;</span><br><span class="line">    if (document.addEventListener) &#123;</span><br><span class="line">        return function(element: HTMLElement,event: Event,handler: any): void &#123;</span><br><span class="line">            if (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return function(element: HTMLElement,event: Event,handler: any): void &#123;</span><br><span class="line">            if (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(&#39;on&#39; + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><p>延后计算，貌似并没有什么用，毕竟一次买一包烟抽一周和一周买一条烟并没有什么本质差别，好处就是参数个数可以随意。见示例解法，就是延迟计算，在最后隐式转换时在一次性相加并返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数柯里化有用吗？有用。用的多吗？并不会。本质也是一个高阶函数的一个特殊用法。对于希望js基础好的，还是应该多多掌握</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhangxinxu.com/wordpress/2013/02/js-currying/comment-page-1/#comments">https://www.zhangxinxu.com/wordpress/2013/02/js-currying/comment-page-1/#comments</a></p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 柯里化 复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es2020新特性</title>
      <link href="/2020/09/01/es2020%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/"/>
      <url>/2020/09/01/es2020%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>ES2020</strong>是ECMA, <a href="https://link.zhihu.com/?target=https://github.com/tc39">TC39</a>（技术委员会）发布的最新的JavaScript版本。</p><p><strong>ECMA</strong>全名<strong>European Computer Manufacturers Association</strong>（欧洲计算机制造商协会），是一个和ISO、W3C一样国际标准组织。</p><a id="more"></a><h2 id="合并空运算符"><a href="#合并空运算符" class="headerlink" title="合并空运算符"></a>合并空运算符</h2><p>在开发中，为了确保某个字段存在，我们往往会用c = a || b的方式，当a不存在时，确保c有个初始值b,但这种在a=0或者a=’’时会出错，让我们不得不对这些特殊值另加判断。<br>ES2020出了新的判断符号？？确保a只在为null或undefined是，在会执行右边</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(age || <span class="number">18</span>) <span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(age ?? <span class="number">18</span>) <span class="comment">//0</span></span><br><span class="line">??可精确比较 为<span class="literal">null</span>或underfined才为后者</span><br></pre></td></tr></table></figure><h2 id="链接操作符"><a href="#链接操作符" class="headerlink" title="链接操作符"></a>链接操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (res1 &amp;&amp; res1.data &amp;&amp; res1.data.data &amp;&amp; res1.data.data.hasProcessing) &#123;...&#125;</span><br><span class="line">if(res1?.data?.data?.hasProcessing)</span><br></pre></td></tr></table></figure><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">promise.all可以一起调用多个任务，一个任务出错，就全错了，新的可以确保其他的都能正常运行</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">200</span>, <span class="string">&#x27;ok&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;bad&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会触发</span></span><br><span class="line">   &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// bad</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 会触发，获取不到我们想要的内容</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises)</span><br><span class="line">  .then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// &#123;status: &quot;fulfilled&quot;, value: &quot;ok&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#123;status: &quot;rejected&quot;, reason: &quot;bad&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="大整数bigInt"><a href="#大整数bigInt" class="headerlink" title="大整数bigInt"></a>大整数bigInt</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js最大整数为<span class="number">2</span>^<span class="number">53</span><span class="number">-1</span>,<span class="attr">numbe</span>:MAX_SAFE_INTERGEF,超过这个值后，运算会造成精度丢失</span><br><span class="line">数字后面加n  如<span class="number">2n</span> == <span class="number">2</span>/<span class="literal">true</span> <span class="number">2n</span>===<span class="number">2</span>/<span class="literal">false</span></span><br><span class="line">大整数只能和大整数进行运算 </span><br><span class="line">number(<span class="number">2n</span>) bigInt(<span class="number">2</span>)转换，精度会丢失</span><br><span class="line">+ - 不会隐式转换 会报错</span><br><span class="line">其他运算基本和number相同</span><br></pre></td></tr></table></figure><h2 id="动态引入（next已经支持）"><a href="#动态引入（next已经支持）" class="headerlink" title="动态引入（next已经支持）"></a>动态引入（next已经支持）</h2><p>利用async await 实现某些组件按需加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const addForMath &#x3D; async (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  if (a &amp;&amp; b) &#123;</span><br><span class="line">    const math &#x3D; await import(&#39;.&#x2F;math.js&#39;);</span><br><span class="line">    console.log(math.add(5, 10));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 ES2020 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
